name: WikiDocumentation

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  actions: write

env:
  WIKI_URL: "http://wiki.franquinho.info/graphql"
  #WIKI_URL: "http://cyberwiki.internal.ctt.pt/graphql"
  #WIKI_API_TOKEN: ${{ secrets.WIKI_API_TOKEN_WIKILAB2  }}
  WIKI_API_TOKEN: ${{ secrets.WIKI_API_TOKEN }}
  WIKI_LOCALE: "en"
  BASE_PATH: "Pedro/Aplica√ß√µes"
  REPO_NAME: ${{ vars.APP_NAME }}
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} 

jobs:
  setup-env:
    name: "Setup Environment"
    runs-on: ubuntu-latest
    outputs:
      BASE_PATH_SAFE: ${{ steps.export.outputs.BASE_PATH_SAFE }}
    steps:
      - name: Compute BASE_PATH_SAFE
        id: export
        run: |
          set -euo pipefail
          raw="${BASE_PATH:-}"
          safe=$(echo "$raw" | iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null)
          safe=$(echo "$safe" | sed 's/[^a-zA-Z0-9\/-]//g')
          safe=$(echo "$safe" | sed 's#//*#/#g')
          safe="${safe%/}"
          echo "BASE_PATH_SAFE=$safe"
          echo "BASE_PATH_SAFE=$safe" >> "$GITHUB_OUTPUT"

  check-altered-files:
    name: "Check Changed Files"
    runs-on: ubuntu-latest
    outputs:
      docs_changed: ${{ steps.check.outputs.docs_changed }}
      readme_changed: ${{ steps.check.outputs.readme_changed }}
      changelog_changed: ${{ steps.check.outputs.changelog_changed }}
      doc_files_changed: ${{ steps.check.outputs.doc_files_changed }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Get changed files
        id: changed-files
        run: |
            # If github.event.before is empty (e.g., first commit or manual run), fallback to comparing with the previous commit or list all files
            if [ -z "${{ github.event.before }}" ] || [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
              # If this is the first commit or before is empty, list all tracked files (including added ones)
              git ls-files > changed_files.txt
            else
              git fetch origin ${{ github.event.before }}
              git diff --name-only ${{ github.event.before }} ${{ github.sha }} > changed_files.txt
            fi
            cat changed_files.txt
            changed_files=$(cat changed_files.txt | tr '\n' ' ')
            echo "Changed files: $changed_files"

      - name: Check if documentation files changed
        id: check
        run: |
          if grep -qE '^documentation/.*\.md$' changed_files.txt; then
            echo "Documentation files have changed."
            echo "docs_changed=true" >> "$GITHUB_OUTPUT"
            
            # Get the list of changed documentation files for debugging
            echo "Changed documentation files:"
            DOC_FILES_CHANGED=$(grep -E '^documentation/.*\.md$' changed_files.txt)
            echo "$DOC_FILES_CHANGED"
            DOC_FILES_CHANGED=($DOC_FILES_CHANGED)
            echo "DOC_FILES_CHANGED=${DOC_FILES_CHANGED[*]}" >> "$GITHUB_OUTPUT"
          else
            echo "No documentation files have changed."
            echo "docs_changed=false" >> "$GITHUB_OUTPUT"
          fi

          if grep -qE '^README\.md$' changed_files.txt; then
            echo "README.md has changed."
            echo "readme_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "README.md has not changed."
            echo "readme_changed=false" >> "$GITHUB_OUTPUT"
          fi

          if grep -qE '^CHANGELOG\.md$' changed_files.txt; then
            echo "CHANGELOG.md has changed."
            echo "changelog_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "CHANGELOG.md has not changed."
            echo "changelog_changed=false" >> "$GITHUB_OUTPUT"
          fi
  
  check-pages-folders:
    name: "Check if Pages and Folders are created"
    runs-on: ubuntu-latest
    outputs:
      has_repo_path: ${{ steps.check.outputs.has_repo_path }}
      has_documentation_folder: ${{ steps.check.outputs.has_documentation_folder }}
      has_readme_page: ${{ steps.check.outputs.has_readme_page }}
      has_changelog_page: ${{ steps.check.outputs.has_changelog_page }}
      repo_path: ${{ steps.check.outputs.repo_path }}
      missing_files: ${{ steps.check.outputs.missing_files }}
      docs_files: ${{ steps.check.outputs.docs_files }}
      missing_count: ${{ steps.check.outputs.missing_count }}
    
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Query Wiki.js and verify structure
        id: check
        run: |
          set -euo pipefail

          # Definir Paths
          REPO_PATH="$(echo "${BASE_PATH}/${REPO_NAME}" | sed 's#//*#/#g' | sed 's#/$##')"
          DOC_PREFIX="$(echo "${REPO_PATH}/documentation/" | sed 's#//*#/#g')"
          README_PATH="$(echo "${REPO_PATH}/readme" | sed 's#//*#/#g')"
          CHANGELOG_PATH="$(echo "${REPO_PATH}/changelog" | sed 's#//*#/#g')"

          echo "üîç Verifica√ß√µes:"
          echo "  ‚Ä¢ REPO_PATH      = $REPO_PATH"
          echo "  ‚Ä¢ DOC_PREFIX     = $DOC_PREFIX"
          echo

          QUERY=$(cat <<'GRAPHQL'
          query ($locale: String!) {
            pages {
              list(locale: $locale) {
                id
                path
                title
              }
            }
          }
          GRAPHQL
          )

          JSON_PAYLOAD=$(jq -n --arg q "$QUERY" --arg loc "$WIKI_LOCALE" '{query: $q, variables: { locale: $loc }}')

          echo "Querying Wiki.js for all pages..."

          RESULT=$(curl -sS -X POST "$WIKI_URL" \
            -H "Authorization: Bearer $WIKI_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$JSON_PAYLOAD")
          
          echo "$RESULT" | jq .

          # Verrificar se Existem erros no resultado
          ERR_CNT=$(echo "$RESULT" | jq '.errors | length // 0')
          if [ "$ERR_CNT" -gt 0 ]; then
            echo "‚ùå Erros na consulta:"
            echo "$RESULT" | jq '.errors'
            exit 1
          fi

          # Flags para verificar se os paths existem
          HAS_REPO_PATH=$(echo "$RESULT" | jq --arg path "$REPO_PATH" '[.data.pages.list[] | select(.path | startswith($path))] | length > 0')
          HAS_DOCUMENTATION_FOLDER=$(echo "$RESULT" | jq --arg path "$DOC_PREFIX" '[.data.pages.list[] | select(.path | startswith($path))] | length > 0')
          HAS_README_PAGE=$(echo "$RESULT" | jq --arg path "$README_PATH" '[.data.pages.list[] | select(.path == $path)] | length > 0')
          HAS_CHANGELOG_PAGE=$(echo "$RESULT" | jq --arg path "$CHANGELOG_PATH" '[.data.pages.list[] | select(.path == $path)] | length > 0')


          # List all .md files in documentation folder
          DOC_FILES=$(find documentation -type f -name "*.md" | sed 's#^documentation/##')
          DOC_FILES=($DOC_FILES)  # Convert to array

          # Remove the Extension from the filenames
          for i in "${!DOC_FILES[@]}"; do
            DOC_FILES[$i]=$(basename "${DOC_FILES[$i]}" .md)
          done

          # Verificar se esses arquivos existem na Wiki
          MISSING_FILES=()
          for FILE in "${DOC_FILES[@]}"; do
            FILE_PATH="${DOC_PREFIX}${FILE}"
            # echo "  ‚Ä¢ Checking if $FILE_PATH exists in Wiki..."
            EXISTS=$(echo "$RESULT" | jq --arg path "$FILE_PATH" '[.data.pages.list[] | select(.path == $path)] | length > 0')
            if [ "$EXISTS" != "true" ]; then
              MISSING_FILES+=("$FILE_PATH")
            fi
          done

          if [ ${#MISSING_FILES[@]} -gt 0 ]; then
            echo "  ‚Ä¢ Missing documentation files in Wiki:"
            for FILE in "${MISSING_FILES[@]}"; do
              echo "    - $FILE"
            done
          fi
          echo "‚úÖ Verifica√ß√µes conclu√≠das."

          # Set outputs
          echo "has_repo_path=$HAS_REPO_PATH" >> $GITHUB_OUTPUT
          echo "has_documentation_folder=$HAS_DOCUMENTATION_FOLDER" >> $GITHUB_OUTPUT
          echo "has_readme_page=$HAS_README_PAGE" >> $GITHUB_OUTPUT
          echo "has_changelog_page=$HAS_CHANGELOG_PAGE" >> $GITHUB_OUTPUT
          echo "repo_path=$REPO_PATH" >> $GITHUB_OUTPUT
          echo "missing_files=${MISSING_FILES[*]}" >> $GITHUB_OUTPUT
          echo "missing_count=${#MISSING_FILES[@]}" >> "$GITHUB_OUTPUT"
          echo "docs_files=${DOC_FILES[*]}" >> $GITHUB_OUTPUT

          # Echo dos outputs para debug
          echo "‚úÖ Outputs set:"
          echo "  ‚Ä¢ has_repo_path = $HAS_REPO_PATH"
          echo "  ‚Ä¢ has_documentation_folder = $HAS_DOCUMENTATION_FOLDER"
          echo "  ‚Ä¢ has_readme_page = $HAS_README_PAGE"
          echo "  ‚Ä¢ has_changelog_page = $HAS_CHANGELOG_PAGE"
          echo "  ‚Ä¢ missing_files = ${MISSING_FILES[*]}"
          echo "  ‚Ä¢ docs_files = ${DOC_FILES[*]}"

#Cria√ß√£o de P√°ginas
  create-missing-files:
    name: "Create Missing Documentation Files"
    runs-on: ubuntu-latest
    needs: [check-pages-folders]
    if: fromJSON(needs.check-pages-folders.outputs.missing_count) > 0
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Create Documentation Missing Files
        run: |
          REPO_PATH="$(echo "${BASE_PATH}/${REPO_NAME}" | sed 's#//*#/#g' | sed 's#/$##')"
          DOC_PREFIX="$(echo "${REPO_PATH}/documentation/" | sed 's#//*#/#g')"

          # Read missing files from output
          missing_files=(${{ needs.check-pages-folders.outputs.missing_files }})
          echo "Missing files to create: ${missing_files[*]}"

          for FILE in "${missing_files[@]}"; do
            echo "  ‚Ä¢ Will create: $FILE"
            # Define source markdown file
            src_md="documentation/$(basename "$FILE").md"

            # Read Content from the source markdown file
            CONTENT=$(<"$src_md")

            # Rewrite links just in case (maybe not needed cause its already at the doc folder)
            CONTENT=$(
              printf '%s\n' "$CONTENT" | sed -E \
                -e 's#\]\([[:space:]]*/documentation/#](./documentation/#g' \
                -e 's#\]\([[:space:]]*documentation/#](./documentation/#g' \
                -e 's#\]\([[:space:]]*\./documentation/([^)]*)\.md([?#][^)]*)\)#](./documentation/\1\2)#g' \
                -e 's#\]\([[:space:]]*\./documentation/([^)]*)\.md\)#](./documentation/\1)#g'
            )
            
            CONTENT_JSON=$(jq -n --arg c "$CONTENT" '$c')

            # Build GraphQL query
            TITLE="$(basename "$FILE")"
            echo "    - Title: $TITLE"

            # Build GraphQL query in a variable (no expansion inside)
            QUERY='mutation ($content: String!, $locale: String!, $path: String!, $title: String!) { pages { create(path: $path, title: $title, content: $content, editor: "markdown", isPrivate: false, isPublished: true, locale: $locale, tags: [], description: "") { responseResult { succeeded slug message } page { id title path updatedAt } } } }'


            # Build payload: pass the query + variables; jq escapes values safely
            JSON_PAYLOAD=$(jq -n \
              --arg q "$QUERY" \
              --arg content "$CONTENT" \
              --arg loc "$WIKI_LOCALE" \
              --arg path "$FILE" \
              --arg title "$TITLE" \
              '{query: $q, variables: { content: $content, locale: $loc, path: $path, title: $title }}')

            RESULT=$(curl -s -X POST "$WIKI_URL" \
              -H "Authorization: Bearer $WIKI_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$JSON_PAYLOAD")
            
            echo "$RESULT" | jq .

            SUCCEEDED=$(echo "$RESULT" | jq -r '.data.pages.create.responseResult.succeeded // empty')
            
            if [ "$SUCCEEDED" = "true" ]; then
              echo "‚úÖ Created: $FILE"
              PAGE_ID=$(echo "$RESULT" | jq -r .data.pages.create.page.id)
              echo "Page ID: $PAGE_ID"

              TITLE_SAFE="${TITLE^^}"
              TITLE_SAFE="${TITLE_SAFE//[^A-Z0-9_]/_}"
              VAR_NAME="WIKI_${TITLE_SAFE}_ID"

              echo "Saving $VAR_NAME=$PAGE_ID to repository variables‚Ä¶"

              #gh variable set "$VAR_NAME" --body "$PAGE_ID"
            else
              echo "‚ö†Ô∏è Failed to create: $FILE"
              echo "$RESULT" | jq .errors
              exit 1
            fi

          done
  
  create-readme-page:
    name: "Create README Page if missing"
    runs-on: ubuntu-latest
    needs: [check-pages-folders]
    if: needs.check-pages-folders.outputs.has_readme_page == 'false'
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
      
      - name: Create README Page in Wiki.js
        run: |
          set -euo pipefail

          # ------------------------------------------------------------
          # 1Ô∏è‚É£ Construir o caminho REPO_PATH de forma segura
          # ------------------------------------------------------------
          REPO_PATH="$(echo "${BASE_PATH}/${REPO_NAME}" | sed 's#//*#/#g' | sed 's#/$##')"
          README_PATH="$(echo "${REPO_PATH}/readme" | sed 's#//*#/#g')"

          echo "üìÇ BASE_PATH: ${BASE_PATH}"
          echo "üìÑ REPO_PATH: ${REPO_PATH}"
          echo "üìò README_PATH: ${README_PATH}"

          # ------------------------------------------------------------
          # 3Ô∏è‚É£ Ler o conte√∫do do README.md (sem CRLF)
          # ------------------------------------------------------------
          if [ ! -f README.md ]; then
            echo "‚ùå README.md n√£o encontrado no reposit√≥rio."
            exit 1
          fi
          CONTENT=$(tr -d '\r' < README.md)

          # ------------------------------------------------------------
          # 4Ô∏è‚É£ Reescrever links relativos (para documenta√ß√£o local)
          # ------------------------------------------------------------
          CONTENT=$(
            printf '%s\n' "$CONTENT" | sed -E \
              -e 's#\]\([[:space:]]*/documentation/#](./documentation/#g' \
              -e 's#\]\([[:space:]]*documentation/#](./documentation/#g' \
              -e 's#\]\([[:space:]]*\./documentation/([^)]*)\.md([?#][^)]*)\)#](./documentation/\1\2)#g' \
              -e 's#\]\([[:space:]]*\./documentation/([^)]*)\.md\)#](./documentation/\1)#g'
          )

          # ------------------------------------------------------------
          # 5Ô∏è‚É£ Construir query GraphQL
          # ------------------------------------------------------------
          QUERY='mutation ($content: String!, $locale: String!, $path: String!) {
            pages {
              create(
                path: $path,
                title: "README",
                content: $content,
                editor: "markdown",
                isPrivate: false,
                isPublished: true,
                locale: $locale,
                tags: [],
                description: ""
              ) {
                responseResult { succeeded slug message }
                page { id title path updatedAt }
              }
            }
          }'

          JSON_PAYLOAD=$(jq -n \
            --arg q "$QUERY" \
            --arg content "$CONTENT" \
            --arg loc "$WIKI_LOCALE" \
            --arg path "$README_PATH" \
            '{ query: $q, variables: { content: $content, locale: $loc, path: $path } }')

          # ------------------------------------------------------------
          # 6Ô∏è‚É£ Enviar para Wiki.js
          # ------------------------------------------------------------
          echo "üöÄ Enviando para Wiki.js..."
          RESULT=$(curl -s -X POST "$WIKI_URL" \
            -H "Authorization: Bearer $WIKI_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$JSON_PAYLOAD")

          echo "$RESULT" | jq .

          SUCCEEDED=$(echo "$RESULT" | jq -r '.data.pages.create.responseResult.succeeded // empty')
          if [ "$SUCCEEDED" = "true" ]; then
            PAGE_ID=$(echo "$RESULT" | jq -r .data.pages.create.page.id)
            echo "‚úÖ P√°gina criada com sucesso!"
            echo "üÜî Page ID: $PAGE_ID"
          else
            echo "‚ö†Ô∏è Falha ao criar p√°gina README"
            echo "$RESULT" | jq -r '.data.pages.create.responseResult.message'
            exit 1
          fi

  
  create-changelog-page:
    name: "Create CHANGELOG Page if missing"
    runs-on: ubuntu-latest
    needs: [check-pages-folders, create-readme-page]
    if: needs.check-pages-folders.outputs.has_changelog_page == 'false'
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Create CHANGELOG Page in Wiki.js
        run: |
          set -euo pipefail

          # ------------------------------------------------------------
          # 1Ô∏è‚É£ Construir caminho REPO_PATH e CHANGELOG_PATH
          # ------------------------------------------------------------
          REPO_PATH="$(echo "${BASE_PATH}/${REPO_NAME}" | sed 's#//*#/#g' | sed 's#/$##')"
          CHANGELOG_PATH="$(echo "${REPO_PATH}/changelog" | sed 's#//*#/#g')"
          echo "üìÑ CHANGELOG_PATH: ${CHANGELOG_PATH}"

          # ------------------------------------------------------------
          # 3Ô∏è‚É£ Ler o conte√∫do do ficheiro CHANGELOG.md
          # ------------------------------------------------------------
          if [ ! -f CHANGELOG.md ]; then
            echo "‚ùå Ficheiro CHANGELOG.md n√£o encontrado no reposit√≥rio."
            exit 1
          fi

          CONTENT=$(tr -d '\r' < CHANGELOG.md)
          echo "‚úÖ Conte√∫do do CHANGELOG carregado."

          # ------------------------------------------------------------
          # 4Ô∏è‚É£ Construir query GraphQL
          # ------------------------------------------------------------
          QUERY='mutation ($content: String!, $locale: String!, $path: String!) {
            pages {
              create(
                path: $path,
                title: "CHANGELOG",
                content: $content,
                editor: "markdown",
                isPrivate: false,
                isPublished: true,
                locale: $locale,
                tags: [],
                description: "All notable changes to this project will be documented in this file."
              ) {
                responseResult { succeeded slug message }
                page { id title path updatedAt }
              }
            }
          }'

          JSON_PAYLOAD=$(jq -n \
            --arg q "$QUERY" \
            --arg content "$CONTENT" \
            --arg loc "$WIKI_LOCALE" \
            --arg path "$CHANGELOG_PATH" \
            '{ query: $q, variables: { content: $content, locale: $loc, path: $path } }')

          # ------------------------------------------------------------
          # 5Ô∏è‚É£ Enviar para Wiki.js
          # ------------------------------------------------------------
          echo "üöÄ Criando p√°gina CHANGELOG..."
          RESULT=$(curl -s -X POST "$WIKI_URL" \
            -H "Authorization: Bearer $WIKI_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$JSON_PAYLOAD")

          echo "$RESULT" | jq .

          SUCCEEDED=$(echo "$RESULT" | jq -r '.data.pages.create.responseResult.succeeded // empty')
          if [ "$SUCCEEDED" = "true" ]; then
            PAGE_ID=$(echo "$RESULT" | jq -r .data.pages.create.page.id)
            echo "‚úÖ P√°gina CHANGELOG criada com sucesso!"
            echo "üÜî Page ID: $PAGE_ID"
          else
            echo "‚ö†Ô∏è Falha ao criar p√°gina CHANGELOG"
            echo "$RESULT" | jq -r '.data.pages.create.responseResult.message'
            exit 1
          fi


# Updates de P√°ginas
  update-docs-content:
    name: "Update Documentation Files in Wiki"
    runs-on: ubuntu-latest
    needs: [check-pages-folders, check-altered-files]
    if: always()
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Query Wiki.js for existing pages
        id: query
        run: |
          set -euo pipefail
          echo "üîç Querying Wiki.js for existing pages..."

          REPO_PATH="$(echo "${BASE_PATH}/${REPO_NAME}" | sed 's#//*#/#g' | sed 's#/$##')"

          QUERY='query ($locale: String!) { pages { list(locale: $locale) { id title path } } }'
          JSON_PAYLOAD=$(jq -n --arg q "$QUERY" --arg loc "$WIKI_LOCALE" '{query: $q, variables: { locale: $loc }}')

          RESULT=$(curl -sS -X POST "$WIKI_URL" \
            -H "Authorization: Bearer $WIKI_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$JSON_PAYLOAD")

          echo "$RESULT" | jq '.data.pages.list[] | select(.path | startswith("'"$REPO_PATH"'")) | {id, title, path}'

          # Exportar IDs como vari√°veis de ambiente
          echo "$RESULT" | jq -r --arg path "$REPO_PATH" \
            '.data.pages.list[]
             | select(.path | startswith($path))
             | "WIKI_PAGE_\(.title | ascii_upcase)="+(.id|tostring)' >> $GITHUB_ENV

          echo "‚úÖ Exported page IDs to environment."

      - name: Update the Files in Wiki
        run: |
          set -euo pipefail

          REPO_PATH="$(echo "${BASE_PATH}/${REPO_NAME}" | sed 's#//*#/#g' | sed 's#/$##')"
          DOC_ROOT="$(echo "${REPO_PATH}/documentation/" | sed 's#//*#/#g')"

          # List all documentation files from the output
          docs_files=(${{ needs.check-pages-folders.outputs.docs_files }})
          echo "üìò Documentation files found: ${docs_files[*]}"

          # Remove Missing files (they will be created elsewhere)
          missing_files=(${{ needs.check-pages-folders.outputs.missing_files }})
          for MISSING in "${missing_files[@]}"; do
            MISSING_BASENAME="$(basename "$MISSING")"
            docs_files=("${docs_files[@]/$MISSING_BASENAME}")
          done
          echo "üìÑ After removing missing files: ${docs_files[*]}"

          # Keep only changed documentation files
          changed_files=(${{ needs.check-altered-files.outputs.doc_files_changed }})
          for i in "${!changed_files[@]}"; do
            changed_files[$i]=$(basename "${changed_files[$i]}" .md)
          done
          for i in "${!docs_files[@]}"; do
            if [[ ! " ${changed_files[*]} " =~ " ${docs_files[$i]} " ]]; then
              unset 'docs_files[i]'
            fi
          done

          if [ ${#docs_files[@]} -eq 0 ]; then
            echo "‚ÑπÔ∏è No documentation files to update. Exiting."
            exit 0
          fi

          for FILE in "${docs_files[@]}"; do
            echo "üìù Updating: $FILE"
            src_md="documentation/${FILE}.md"
            CONTENT=$(<"$src_md")

            # Rewrite internal links
            CONTENT=$(printf '%s\n' "$CONTENT" | sed -E \
              -e 's#\]\([[:space:]]*/documentation/#](./documentation/#g' \
              -e 's#\]\([[:space:]]*documentation/#](./documentation/#g' \
              -e 's#\]\([[:space:]]*\./documentation/([^)]*)\.md([?#][^)]*)\)#](./documentation/\1\2)#g' \
              -e 's#\]\([[:space:]]*\./documentation/([^)]*)\.md\)#](./documentation/\1)#g'
            )

            # Determine the page ID dynamically from environment
            TITLE_SAFE="${FILE^^}"
            TITLE_SAFE="${TITLE_SAFE//[^A-Z0-9_]/_}"
            PAGE_ID_VAR="WIKI_PAGE_${TITLE_SAFE}"
            PAGE_ID="${!PAGE_ID_VAR:-}"

            if [ -z "$PAGE_ID" ]; then
              echo "‚ö†Ô∏è No existing Wiki page for '$FILE' found (skipping)."
              continue
            fi

            echo "üîó Found Wiki Page ID: $PAGE_ID"

            # Build GraphQL mutation
            QUERY='mutation ($id: Int!, $content: String!, $locale: String!) {
              pages {
                update(id: $id, content: $content, editor: "markdown",
                       isPrivate: false, isPublished: true, locale: $locale, tags: []) {
                  responseResult { succeeded message }
                  page { id title path updatedAt }
                }
              }
            }'

            JSON_PAYLOAD=$(jq -n \
              --arg q "$QUERY" \
              --argjson id "$PAGE_ID" \
              --arg content "$CONTENT" \
              --arg loc "$WIKI_LOCALE" \
              '{query: $q, variables: { id: $id, content: $content, locale: $loc }}')

            RESULT=$(curl -s -X POST "$WIKI_URL" \
              -H "Authorization: Bearer $WIKI_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$JSON_PAYLOAD")

            SUCCEEDED=$(echo "$RESULT" | jq -r '.data.pages.update.responseResult.succeeded // empty')
            if [ "$SUCCEEDED" = "true" ]; then
              echo "‚úÖ Successfully updated: $FILE"
            else
              echo "‚ö†Ô∏è Failed to update: $FILE"
              echo "$RESULT" | jq .errors
              exit 1
            fi
          done


  update-readme-content:
    name: "Update ReadMe in Wiki"
    runs-on: ubuntu-latest
    needs: [check-pages-folders, check-altered-files]
    if: needs.check-altered-files.outputs.readme_changed == 'true'
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Find README page ID in Wiki.js
        id: find_readme
        run: |
          set -euo pipefail
          echo "üîç Searching README page in Wiki.js..."

          REPO_PATH="$(echo "${BASE_PATH}/${REPO_NAME}" | sed 's#//*#/#g' | sed 's#/$##')"
          README_PATH="$(echo "${REPO_PATH}/readme" | sed 's#//*#/#g')"

          QUERY='query ($locale: String!) { pages { list(locale: $locale) { id path title } } }'
          JSON_PAYLOAD=$(jq -n --arg q "$QUERY" --arg loc "$WIKI_LOCALE" '{query: $q, variables: { locale: $loc }}')

          RESULT=$(curl -sS -X POST "$WIKI_URL" \
            -H "Authorization: Bearer $WIKI_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$JSON_PAYLOAD")

          PAGE_ID=$(echo "$RESULT" | jq -r --arg path "$README_PATH" \
                     '.data.pages.list[] | select(.path == $path) | .id')

          if [ -z "$PAGE_ID" ] || [ "$PAGE_ID" = "null" ]; then
            echo "‚ö†Ô∏è README page not found in Wiki. Skipping update."
            echo "found=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found README page ID: $PAGE_ID"
            echo "found=true" >> $GITHUB_OUTPUT
            echo "page_id=$PAGE_ID" >> $GITHUB_OUTPUT
          fi

      - name: Update README content in Wiki.js
        if: steps.find_readme.outputs.found == 'true'
        run: |
          set -euo pipefail
          PAGE_ID="${{ steps.find_readme.outputs.page_id }}"

          CONTENT=$(tr -d '\r' < README.md)
          CONTENT=$(printf '%s\n' "$CONTENT" | sed -E \
            -e 's#\]\([[:space:]]*/documentation/#](./documentation/#g' \
            -e 's#\]\([[:space:]]*documentation/#](./documentation/#g' \
            -e 's#\]\([[:space:]]*\./documentation/([^)]*)\.md([?#][^)]*)\)#](./documentation/\1\2)#g' \
            -e 's#\]\([[:space:]]*\./documentation/([^)]*)\.md\)#](./documentation/\1)#g')

          QUERY='mutation ($id: Int!, $content: String!, $locale: String!) {
            pages {
              update(id: $id, content: $content, editor: "markdown",
                     isPrivate: false, isPublished: true, locale: $locale) {
                responseResult { succeeded message }
              }
            }
          }'

          JSON_PAYLOAD=$(jq -n \
            --arg q "$QUERY" \
            --argjson id "$PAGE_ID" \
            --arg content "$CONTENT" \
            --arg loc "$WIKI_LOCALE" \
            '{query: $q, variables: { id: $id, content: $content, locale: $loc }}')

          RESULT=$(curl -s -X POST "$WIKI_URL" \
            -H "Authorization: Bearer $WIKI_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$JSON_PAYLOAD")

          SUCCESS=$(echo "$RESULT" | jq -r '.data.pages.update.responseResult.succeeded')
          if [ "$SUCCESS" = "true" ]; then
            echo "‚úÖ README updated successfully."
          else
            echo "‚ö†Ô∏è README update failed."
            echo "$RESULT" | jq .
            exit 1
          fi

  update-changelog-content:
    name: "Update Changelog in Wiki"
    runs-on: ubuntu-latest
    needs: [check-pages-folders, check-altered-files, update-readme-content]
    if: needs.check-altered-files.outputs.changelog_changed == 'true'
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Find CHANGELOG page ID in Wiki.js
        id: find_changelog
        run: |
          set -euo pipefail
          echo "üîç Searching CHANGELOG page in Wiki.js..."

          REPO_PATH="$(echo "${BASE_PATH}/${REPO_NAME}" | sed 's#//*#/#g' | sed 's#/$##')"
          CHANGELOG_PATH="$(echo "${REPO_PATH}/changelog" | sed 's#//*#/#g')"

          QUERY='query ($locale: String!) { pages { list(locale: $locale) { id path title } } }'
          JSON_PAYLOAD=$(jq -n --arg q "$QUERY" --arg loc "$WIKI_LOCALE" '{query: $q, variables: { locale: $loc }}')

          RESULT=$(curl -sS -X POST "$WIKI_URL" \
            -H "Authorization: Bearer $WIKI_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$JSON_PAYLOAD")

          PAGE_ID=$(echo "$RESULT" | jq -r --arg path "$CHANGELOG_PATH" \
                     '.data.pages.list[] | select(.path == $path) | .id')

          if [ -z "$PAGE_ID" ] || [ "$PAGE_ID" = "null" ]; then
            echo "‚ö†Ô∏è CHANGELOG page not found in Wiki. Skipping update."
            echo "found=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found CHANGELOG page ID: $PAGE_ID"
            echo "found=true" >> $GITHUB_OUTPUT
            echo "page_id=$PAGE_ID" >> $GITHUB_OUTPUT
          fi

      - name: Update CHANGELOG content in Wiki.js
        if: steps.find_changelog.outputs.found == 'true'
        run: |
          set -euo pipefail
          PAGE_ID="${{ steps.find_changelog.outputs.page_id }}"

          CONTENT=$(tr -d '\r' < CHANGELOG.md)

          QUERY='mutation ($id: Int!, $content: String!, $locale: String!) {
            pages {
              update(id: $id, content: $content, editor: "markdown",
                     isPrivate: false, isPublished: true, locale: $locale) {
                responseResult { succeeded message }
              }
            }
          }'

          JSON_PAYLOAD=$(jq -n \
            --arg q "$QUERY" \
            --argjson id "$PAGE_ID" \
            --arg content "$CONTENT" \
            --arg loc "$WIKI_LOCALE" \
            '{query: $q, variables: { id: $id, content: $content, locale: $loc }}')

          RESULT=$(curl -s -X POST "$WIKI_URL" \
            -H "Authorization: Bearer $WIKI_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$JSON_PAYLOAD")

          SUCCESS=$(echo "$RESULT" | jq -r '.data.pages.update.responseResult.succeeded')
          if [ "$SUCCESS" = "true" ]; then
            echo "‚úÖ CHANGELOG updated successfully."
          else
            echo "‚ö†Ô∏è CHANGELOG update failed."
            echo "$RESULT" | jq .
            exit 1
          fi

# Upload de M√≠dia
  upload-docs-media:
    name: "Upload Documentation Media"
    runs-on: ubuntu-latest
    needs: [setup-env]
    env:
      BASE_PATH_SAFE: ${{ needs.setup-env.outputs.BASE_PATH_SAFE }}
      PARENT_FOLDER_ID: "1"
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Detect Media Files
        id: detect
        run: |
          MEDIA_FILES=$(find documentation/ -type f ! -name "*.md")
          echo "MEDIA_FILES<<EOF" >> "$GITHUB_ENV"
          echo "$MEDIA_FILES" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"
          echo "Ficheiros encontrados:"
          echo "$MEDIA_FILES"

      - name: Get Repository Name
        id: repo
        run: |
          repo_name="${GITHUB_REPOSITORY##*/}"
          echo "REPO_NAME=${repo_name,,}" >> "$GITHUB_ENV"
          echo "Repository name: ${repo_name,,}"

      - name: Criar estrutura de pastas no Wiki.js
        id: criar-pastas
        env:
          WIKI_API_TOKEN: ${{ secrets.WIKI_API_TOKEN }}
        run: |
          set -euo pipefail

          # Nome do reposit√≥rio (pasta n√≠vel 1)
          REPO_NAME="${GITHUB_REPOSITORY##*/}"
          REPO_NAME="${REPO_NAME,,}"

          # Subpasta fixa (n√≠vel 2)
          SUBFOLDER_NAME="documentation"
          BASE_URL="${WIKI_URL%/}"

          if [[ "$BASE_URL" =~ /graphql$ ]]; then
            GRAPHQL_URL="$BASE_URL"
            BASE_URL="${BASE_URL%/graphql}"
            BASE_URL="${BASE_URL%/}"
            UPLOAD_URL="${BASE_URL}/u"
          else
            GRAPHQL_URL="${BASE_URL}/graphql"
            UPLOAD_URL="${BASE_URL}/u"
          fi

          ### Fun√ß√£o para obter ID de uma pasta com base no nome e parentId
          get_folder_id() {
            local parent_id="$1"
            local name="$2"
            local QUERY
            if [ -n "$parent_id" ]; then
              QUERY="query { assets { folders(parentFolderId: $parent_id) { id name } } }"
            else
              QUERY="query { assets { folders { id name } } }"
            fi
            JSON=$(jq -n --arg q "$QUERY" '{ query: $q }')
            RESULT=$(curl -s -X POST "$GRAPHQL_URL" \
              -H "Authorization: Bearer $WIKI_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$JSON")
            echo "$RESULT" | jq -r --arg NAME "$name" '.data.assets.folders[] | select(.name == $NAME) | .id'
          }

          ### Fun√ß√£o para criar pasta
          create_folder() {
            local parent_id="$1"
            local slug="$2"
            local name="$3"
            local ARG_PARENT=""
            if [ -n "$parent_id" ]; then
              ARG_PARENT="parentFolderId: $parent_id, "
            fi
            MUTATION="mutation { assets { createFolder(${ARG_PARENT}slug: \"$slug\", name: \"$name\") { responseResult { succeeded message } } } }"
            JSON=$(jq -n --arg q "$MUTATION" '{ query: $q }')
            RESULT=$(curl -s -X POST "$GRAPHQL_URL" \
              -H "Authorization: Bearer $WIKI_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$JSON")
            echo "$RESULT" | jq .
            SUCCESS=$(echo "$RESULT" | jq -r '.data.assets.createFolder.responseResult.succeeded')
            if [ "$SUCCESS" != "true" ]; then
              echo "‚ùå Erro a criar pasta '$name'"
              exit 1
            fi
          }

          # Passo 1: Criar ou obter pasta do reposit√≥rio (n√≠vel 1)
          echo "üîç A procurar pasta '$REPO_NAME' na raiz dos assets..."
          PARENT_ID=""
          REPO_FOLDER_ID=$(get_folder_id "$PARENT_ID" "$REPO_NAME")

          if [ -z "$REPO_FOLDER_ID" ]; then
            echo "üìÅ Pasta '$REPO_NAME' n√£o encontrada. A criar..."
            create_folder "" "$REPO_NAME" "$REPO_NAME"
            REPO_FOLDER_ID=$(get_folder_id "" "$REPO_NAME")
          else
            echo "‚úÖ Pasta '$REPO_NAME' encontrada com ID $REPO_FOLDER_ID"
          fi

          # Passo 2: Criar ou obter subpasta 'documentation' dentro da anterior
          echo "üîç A procurar subpasta '$SUBFOLDER_NAME' dentro de '$REPO_NAME'..."
          DOC_FOLDER_ID=$(get_folder_id "$REPO_FOLDER_ID" "$SUBFOLDER_NAME")

          if [ -z "$DOC_FOLDER_ID" ]; then
            echo "üìÅ Subpasta '$SUBFOLDER_NAME' n√£o encontrada. A criar..."
            create_folder "$REPO_FOLDER_ID" "$SUBFOLDER_NAME" "$SUBFOLDER_NAME"
            DOC_FOLDER_ID=$(get_folder_id "$REPO_FOLDER_ID" "$SUBFOLDER_NAME")
          else
            echo "‚úÖ Subpasta '$SUBFOLDER_NAME' encontrada com ID $DOC_FOLDER_ID"
          fi

          # Exportar vari√°veis para steps seguintes
          echo "FOLDER_ID=$DOC_FOLDER_ID" >> "$GITHUB_ENV"
          echo "UPLOAD_URL=$UPLOAD_URL" >> "$GITHUB_ENV"
          echo "GRAPHQL_URL=$GRAPHQL_URL" >> "$GITHUB_ENV"

          echo "‚úÖ Estrutura criada: $REPO_NAME/$SUBFOLDER_NAME (ID final: $DOC_FOLDER_ID)"

      - name: Upload Media Files
        env:
          WIKI_API_TOKEN: ${{ secrets.WIKI_API_TOKEN }}
        run: |
          set -euo pipefail
          GRAPHQL_URL="${GRAPHQL_URL:-$WIKI_URL}"
          UPLOAD_URL="${UPLOAD_URL:-${WIKI_URL%/}/u}"
          if [[ "$UPLOAD_URL" =~ /graphql/u$ ]]; then
            TRIMMED="${UPLOAD_URL%/graphql/u}"
            TRIMMED="${TRIMMED%/}"
            UPLOAD_URL="${TRIMMED}/u"
          fi

          DOC_ROOT_FOLDER_ID="${DOC_ROOT_FOLDER_ID:-${FOLDER_ID:-}}"
          if [ -z "$DOC_ROOT_FOLDER_ID" ]; then
            echo "ERROR: DOC_ROOT_FOLDER_ID not defined. Previous step may have failed."
            exit 1
          fi

          if [ -z "${MEDIA_FILES:-}" ]; then
            echo "No media files to upload."
            exit 0
          fi

          call_graphql() {
            local payload="$1"
            curl -s -X POST "$GRAPHQL_URL" \
              -H "Authorization: Bearer $WIKI_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$payload"
          }

          sanitize_slug() {
            local slug
            slug=$(echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]/-/g')
            slug=$(echo "$slug" | sed 's/-\{2,\}/-/g; s/^-//; s/-$//')
            if [ -z "$slug" ]; then
              slug="assets-folder"
            fi
            echo "$slug"
          }

          folders_query='query($parent: Int!) { assets { folders(parentFolderId: $parent) { id name slug } } }'
          create_folder_mutation='mutation($parent: Int!, $slug: String!, $name: String!) { assets { createFolder(parentFolderId: $parent, slug: $slug, name: $name) { responseResult { succeeded message }, folder { id name slug } } } }'

          declare -A FOLDER_CACHE=()

          ensure_child_folder() {
            local parent="$1"
            local name="$2"
            local slug="$3"
            local cache_key="${parent}:${slug}"
            if [[ -n "${FOLDER_CACHE[$cache_key]:-}" ]]; then
              echo "${FOLDER_CACHE[$cache_key]}"
              return 0
            fi

            local payload result folder_id
            payload=$(jq -n \
              --arg q "$folders_query" \
              --argjson parent "$parent" \
              '{ query: $q, variables: { parent: $parent } }')
            result=$(call_graphql "$payload")
            if ! echo "$result" | jq . >/dev/null 2>&1; then
              echo "ERROR: Non-JSON response when querying folders (parent $parent):"
              echo "$result"
              exit 1
            fi
            folder_id=$(echo "$result" | jq -r --arg name "$name" --arg slug "$slug" '
              (.data.assets.folders // [])[]
              | select(
                  (.name // "" | ascii_downcase) == ($name | ascii_downcase)
                  or (.slug // "" | ascii_downcase) == ($slug | ascii_downcase)
                )
              | .id' | head -n 1)
            if [ -n "$folder_id" ] && [ "$folder_id" != "null" ]; then
              FOLDER_CACHE["$cache_key"]="$folder_id"
              echo "$folder_id"
              return 0
            fi

            payload=$(jq -n \
              --arg q "$create_folder_mutation" \
              --argjson parent "$parent" \
              --arg slug "$slug" \
              --arg name "$name" \
              '{ query: $q, variables: { parent: $parent, slug: $slug, name: $name } }')
            result=$(call_graphql "$payload")
            if ! echo "$result" | jq . >/dev/null 2>&1; then
              echo "ERROR: Non-JSON response when creating folder '$name' (parent $parent):"
              echo "$result"
              exit 1
            fi
            local succeeded
            succeeded=$(echo "$result" | jq -r '.data.assets.createFolder.responseResult.succeeded // "false"')
            if [ "$succeeded" != "true" ]; then
              echo "ERROR: Wiki.js reported failure when creating folder '$name' (parent $parent):"
              echo "$result" | jq .
              exit 1
            fi
            folder_id=$(echo "$result" | jq -r '.data.assets.createFolder.folder.id // .data.assets.createFolder.id')
            if [ -z "$folder_id" ] || [ "$folder_id" = "null" ]; then
              echo "ERROR: Folder ID missing after creating '$name' (parent $parent)."
              echo "$result" | jq .
              exit 1
            fi
            FOLDER_CACHE["$cache_key"]="$folder_id"
            echo "$folder_id"
          }

          ensure_path() {
            local parent="$1"
            local path="$2"
            if [ -z "$path" ] || [ "$path" = "." ]; then
              echo "$parent"
              return 0
            fi

            local current="$parent"
            local oldIFS="$IFS"
            IFS='/'
            read -r -a segments <<< "$path"
            IFS="$oldIFS"
            for segment in "${segments[@]}"; do
              [ -z "$segment" ] && continue
              [ "$segment" = "." ] && continue
              if [ "$segment" = ".." ]; then
                echo "ERROR: Unsupported path segment '..' in '$path'."
                exit 1
              fi
              local slug
              slug=$(sanitize_slug "$segment")
              current=$(ensure_child_folder "$current" "$segment" "$slug")
            done
            echo "$current"
          }

          echo "$MEDIA_FILES" | while IFS= read -r filepath || [ -n "$filepath" ]; do
            [ -z "$filepath" ] && continue
            if [ ! -f "$filepath" ]; then
              echo "‚ö†Ô∏è File '$filepath' not found locally, skipping."
              continue
            fi

            target_folder_id="$DOC_ROOT_FOLDER_ID"
            relative_path="$filepath"
            relative_dir=""
            if [[ "$filepath" == documentation/* ]]; then
              relative_path="${filepath#documentation/}"
              if [[ "$relative_path" == */* ]]; then
                relative_dir="${relative_path%/*}"
                target_folder_id=$(ensure_path "$DOC_ROOT_FOLDER_ID" "$relative_dir")
              fi
            fi

            echo "Uploading $filepath"
            RESPONSE_WITH_STATUS=$(curl -s -w "\n%{http_code}" -X POST "$UPLOAD_URL" \
              -H "Authorization: Bearer $WIKI_API_TOKEN" \
              -F "mediaUpload={\"folderId\":$target_folder_id}" \
              -F "mediaUpload=@$filepath")
            HTTP_STATUS=$(echo "$RESPONSE_WITH_STATUS" | tail -n1)
            BODY=$(echo "$RESPONSE_WITH_STATUS" | sed '$d')
            if [[ "$HTTP_STATUS" =~ ^2 ]]; then
              if echo "$BODY" | jq . >/dev/null 2>&1; then
                echo "$BODY" | jq .
              else
                echo "Upload succeeded (HTTP $HTTP_STATUS) for file: $filepath"
                echo "$BODY"
              fi
            else
              echo "Upload failed (HTTP $HTTP_STATUS) for file: $filepath"
              if echo "$BODY" | jq . >/dev/null 2>&1; then
                echo "$BODY" | jq .
              else
                echo "$BODY"
              fi
              exit 1
            fi
          done
